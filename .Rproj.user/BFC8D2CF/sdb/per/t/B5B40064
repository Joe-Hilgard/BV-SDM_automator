{
    "contents" : "# It seems like this will be easier to make from the ePrime file than from a PRT.\n# Check lines 35+ and 50+ for things that change according to length of p!\n# Also header info at line 90+\n\n# What's the deal with these ones that come back as zero complete cases?\n  # It's because they have zero trials that meet one of the conditions, e.g.\n  # They have zero too-slow trials! Not sure what I should do about that.\n  # If I drop that predictor, I add noise;\n    # If I don't drop it, I have singularity.\n# It seems that BV can handle it if I drop that predictor in just that one subject's SDM file.\n# No, it can't, but maybe I can include it as a confound instead of a predictor\n\nremoveDeadCols = T # set to T if you think BV can handle different numbers of columns across SDM files.\nTooSlowConfound = T # set to T to treat TooSlow condition as confound. May allow diff #col across files.\n# Setting both these to TRUE does keep BV from barking at me, this is promising. \n\n# setwd(\"C:/data_2014/Thesis/prt_sdm_automation/BV-SDM_automator\")\n# load predictor conditions:\nconditions = read.delim(\"conditions-Con-Incon.txt\", stringsAsFactors=F)\nprotocol = \"Con-Incon\"\n# First, name predictors & specify timepoints/predictor:\np = c(conditions$predictor); \nk = 9;\nTRlength = 2000\n# Generate names vector based on that:\npredNames = paste(rep(p, each=k), \"_D\", rep(0:(k-1), length(p)), sep=\"\")\n# Specify number of volumes:\nt = 158\n# badbolds vector for IDing SDMs featuring NAs\nbadbolds = c()\n# badMotion data frame for IDing SDMs featuring excess raw motion\nbadMotion = data.frame(NULL)\n# Fourier confounds\nfourier = read.table(\"./movement-files/Modified_Fourier.sdm\", skip=8, header=T)\nfourier = fourier[,1:4] # Removing the \"Constant\" column b/c I think it results in singular matrix\n# read in the data\nmegadata = read.delim(\"eprime_thesis_1fix.txt\") # read in all the data at once\n\n# then restrict it to just one subject's one bold\n  # A loop would start about here, \nfor (sub in unique(megadata$Subject)) {\n  for (bold in 1:6) {\n    print(paste(\"Retrieving data for subject\", sub, \"bold\", bold))\ndat = megadata[megadata$Subject == sub & megadata$Session == bold,] \n\n# Create spreadsheet\nmatrixNames = list(1:t, predNames)\nsdm = matrix(nrow=t, ncol=length(predNames), dimnames=list(1:t, predNames))\n# Get timepoints at which the events happened:\n# if the codes are mutually exclusive & exhaustive they will sum to 64\n  # but can we count on that? no, i'll make a list\ndat$TR = (dat$Mask.OnsetTime - dat$ready.RTTime) / TRlength - 1 # Mask.OnsetTime, or ITI.OnsetTime??\ndat$TR = round(dat$TR)\n\ncodes = vector(\"list\", length(p))\n# Fetch TRs that match each condition\nfor (i in 1:length(conditions$condition)) {\n  command = paste(\"which(\", conditions$condition[i], \")\")\n  logicalTest = eval(parse(text=command))\n  codes[[i]] = dat$TR[logicalTest]\n}\n\n# Populate values of SDM\n#print(paste(\"Populating values of SDM file!\"))\nfor (j in 1:length(p)) {\n  for (i in 1:k) {\n    peak = codes[[j]] + (i - 1)  # nudge it up for lagged predictors\n    peak = peak[peak < t] # no peak should come after the last TR.\n    currCol = (j-1)*k + i\n    sdm[peak,currCol] = 1 # fill in the peaks\n    sdm[-peak, currCol] = 0 # fill in the zeroes\n  }\n}\n\n# NAs in sdm therefore represent a real failure\n# Delete columns with NAs (e.g. no too-slow trials) if removeDeadCols option is T\nif (removeDeadCols == T) {\nif (sum(complete.cases(t(sdm))) < k*length(p)) print(paste(\"Deleting columns from subject\", sub, \"bold\", bold))\nsdm = sdm[, complete.cases(t(sdm))] # returns only complete columns\n}\n\n# DEBUG COMMAND\nprint (sum(complete.cases(sdm)))\nif (sum(complete.cases(sdm)) < 158) badbolds = c(badbolds, paste(\"Subject\", sub, \"Bold\", bold))\n#if (sum(complete.cases(sdm)) < 158) break\n\n# Add motion confounds and fourier confounds. \nif (TooSlowConfound == T) {\n  firstConfoundPredictor = min(grep(\"Slow\", colnames(sdm))[1], dim(sdm)[2] + 1, na.rm=T)\n} else firstConfoundPredictor = dim(sdm)[2] + 1\n\nzeroes = paste(rep(0, 3-nchar(sub)), sep=\"\", collapse=\"\")\nsubSuffix = paste(zeroes, sub, sep=\"\")\nmotionFileDir = \"./movement-files/\"\nmotionFileRTC = paste(\"WIT\", subSuffix, \"_b\", bold, \"_3DMC.rtc\", sep=\"\")\nmotionFileSDM = paste(\"WIT\", subSuffix, \"_b\", bold, \"_3DMC.sdm\", sep=\"\")\nif (length(list.files(motionFileDir, pattern=motionFileRTC)) > 0) {\n  #motion = read.table(file=paste(motionFileDir, motionFileRTC, sep=\"\"), skip=5, header=T)\n  motion = read.delim(file=paste(motionFileDir, motionFileRTC, sep=\"\"), #widths=rep(9, 6),\n                      skip=5, sep=\" \")\n  } else {\n  #motion = read.table(file=paste(motionFileDir, motionFileSDM, sep=\"\"), skip=8, header=T)\n  motion = read.fwf(file=paste(motionFileDir, motionFileSDM, sep=\"\"), widths=rep(12, 6),\n                    skip=9, header=F,\n                    col.names=c(\"Translation_BV-X_mm\", \"Translation_BV-Y_mm\", \"Translation_BV-Z_mm\",\n                                \"Rotation_BV-X_deg\", \"Rotation_BV-Y_deg\", \"Rotation_BV-Z_deg\"))\n  }\n\n# Check range of motion\ncheck = apply(motion, 2, FUN=max) - apply(motion, 2, FUN=min)\nif (sum(check>3)>0) {\n  print(paste(\"Excess motion in subject \", sub, \", bold \", bold, \n              \", column \", names(check)[check>3], sep=\"\"))\n  temp = data.frame(\"subject\" = sub, \"bold\"=bold, \"column\"=names(check)[check>3])\n  badMotion = rbind(badMotion, temp)\n}\n\n# Standardize the motion\nmotion = scale(motion)\n\n# generate first derivatives\n# Could add a check here for spikes (e.g. throw an alarm if dx/dt exceeds 1 at any point)\nmotion.deriv = apply(motion, 2, FUN=diff)\nmotion.deriv = rbind(motion.deriv, 0) # append a zero at the end to coerce fit\nmotion.deriv = scale(motion.deriv) # convert to z-scores\n# plot(1:dim(motion)[1], motion.deriv[,1], typ='l')\ncolnames(motion.deriv) = paste(names(motion), \"_dt\", sep=\"\")\n\n# Fetch VOI motion confound, make 1st derivatives of VOI, and append\nvvdFileName = paste(\"./vvd-files/WIT\", subSuffix, \"_confoundVOI.vvd\", sep=\"\")\nstartRow = 1+158*(bold-1); endRow = startRow+157\nvvd = read.delim(vvdFileName, sep=\"\", stringsAsFactors=F)[startRow:endRow,]\nvvd.deriv = apply(vvd, 2, FUN=diff)\nvvd.deriv = rbind(vvd.deriv, 0)\nvvd.deriv = scale(vvd.deriv)\ncolnames(vvd.deriv) = paste(names(vvd), \"_dt\", sep=\"\")\nvvd = scale(vvd)\n\n# Append the confounds\nsdm = data.frame(sdm, motion, motion.deriv, vvd, vvd.deriv, fourier)\n\n# Check matrix rank\n# stopifnot(qr(sdm)$rank == 40)\n\n# Okay! I think we're there. Just need to export it to a file and add the header.\nexportName = paste(\"./sdms_con-incon/\",\"WIT\", subSuffix, \"_b\", bold, \"_\", protocol, \".sdm\", sep=\"\")\n#print(paste(\"Exporting to file\", exportName)) # Check NrOfPredictors and FirstConfoundPredictor!!\ncat(\"FileVersion:             1\n    \n    NrOfPredictors:          \", dim(sdm)[2],\"\n    NrOfDataPoints:          158\n    IncludesConstant:        0\n    FirstConfoundPredictor:   \",  firstConfoundPredictor, \"    \n    255 50 50   50 255 50   50 50 255   255 255 0   255 0 255   0 255 255\n    \", \n    file=exportName\n)\nwrite.table(sdm, file=exportName, row.names=F, append=T)\n  }\n}\nwrite(badbolds, file=\"badbolds.txt\", ncolumns=1)\nwrite.table(badMotion, file=\"badMotion.txt\", sep=\"\\t\", row.names=F)\n",
    "created" : 1423773362998.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3925148209",
    "id" : "B5B40064",
    "lastKnownWriteTime" : 1423792685,
    "path" : "C:/data_2014/Thesis/prt_sdm_automation/BV-SDM_automator/makeSDM_con-incon.r",
    "project_path" : "makeSDM_con-incon.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}